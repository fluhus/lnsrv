// Command lnsrv (line server) is an HTTP server that serves input lines.
// The lines can be used to distribute labor to worker jobs using simple HTTP
// requests.
//
// Each request to "/" returns the next line in a synchronous manner. When the
// input lines run out, a customizable end-string is emitted. The server can be
// configured to shut down after N end-strings.
//
// Running lnsrv
//
// Command line flags:
//  -end string
//      String to send when no more lines are available. (default "END")
//  -f string
//      File to read from. (default stdin)
//  -n uint
//      Number of ENDs to send before exiting. (default infinite)
//  -port uint
//      Port to listen on. (default 7777)
//
// Calling lnsrv
//
// Python:
//  def get_lnsrv(addr:str, end='END') -> Iterable[str]:
//      """Returns lines generated by Line Server (lnsrv) as an iterable."""
//      line = requests.get(addr).text.strip()
//      while line != end:
//          yield line
//          line = requests.get(addr).text.strip()
//
// Bash:
//  addr="..."
//  line="$(curl $addr)"
//  while [ "$line" != "END" ]; do
//      echo "$line"
//      line="$(curl $addr)"
//  done
package main

import (
	"bufio"
	"flag"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"sync"
	"time"
)

// TODO(amit): Create a status page.

var (
	in   = flag.String("f", "", "File to read from. (default stdin)")
	n    = flag.Uint("n", 0, "Number of ENDs to send before exiting. (default infinite)")
	end  = flag.String("end", "END", "String to send when no more lines are available.")
	port = flag.Uint("port", 7777, "Port to listen on.")
)

func main() {
	flag.Parse()

	var f io.Reader
	var err error
	if *in == "" {
		f = os.Stdin
	} else {
		f, err = os.Open(*in)
		check(err)
	}
	scanner := bufio.NewScanner(f)

	var lock sync.Mutex
	var wait sync.WaitGroup
	wait.Add(1)
	ends := int(*n)

	http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		lock.Lock()
		defer lock.Unlock()

		if !scanner.Scan() {
			fmt.Fprintln(w, *end)
			ends--
			if ends == 0 {
				wait.Done()
			}
			return
		}
		fmt.Fprint(w, scanner.Text())
	})

	go func() {
		log.Fatal(http.ListenAndServe(":"+fmt.Sprint(*port), nil))
	}()

	host, err := os.Hostname()
	check(err)
	log.Println("Listening")
	log.Printf("%v:%v\n", host, *port)

	wait.Wait()
	time.Sleep(1 * time.Second) // Allow last END to be transmitted.
	log.Println("Byeush!")      // That's a cute way of saying 'bye' in Hebrew.
}

func check(err error) {
	if err != nil {
		log.Fatal(err)
	}
}
